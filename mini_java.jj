
PARSER_BEGIN(MyParser)
public class MyParser {
    public static void main(String[] args){
        try {
            String input = readFile(args[0]);
            MyParser parser = new MyParser(new StringReader(input));
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
        }

    }

    private static String readFile(String filePath) throws Exception {
        File file = new File(filePath);
        BufferedReader reader = new BufferedReader(new FileReader(file));
        String line;
        StringBuilder stringBuilder = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            stringBuilder.append(line);
            stringBuilder.append(System.lineSeparator());
        }
        reader.close();
        return stringBuilder.toString();
    }
}
PARSER_END(MyParser)


SKIP :
{ " "
| "\t"
| "\n"
| < "//" (~["\n","\r"])* ("\n" | "\r\n" | "\r") >
| < "/*" (~[])* "*/" >

}
TOKEN :
{ < WHILE: "while" >
| < BEGIN: "begin" >
| < END: "end" >
| < DO: "do" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < SEMI: ";" >
| < ASSIGN: "=" >
| < CLASS: "class" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < MAIN: "main" >
| < NEW: "new" >
| < EXTENDS: "extends" >
| < RETURN: "return" >
| < STRING: "String" >
| < INT: "int" >
| < BOOLEAN: "boolean" >
| < PRINT: "System.out.println" >
| < LENGTH: "length" >
| < TRUE: "true" >
| < FALSE: "false" >
| < THIS: "this" >
| < OP_AND: "&&" >
| < OP_LESS: "<" >
| < OP_ADD: "+" >
| < OP_SUB: "-" >
| < OP_MULT: "*" >
| < #LETTER : ["A"-"Z"] | ["a"-"z"] >
| < ID: <LETTER> (<LETTER> | ["0"-"9"] | "_")* >
| < INTEGER_LITERAL : ["0"-"9"] (["0"-"9"])* >
}

void Prog() : {}
{
    MainClass()
    (ClassDeclaration())*
    <EOF>
}

void MainClass() : {}
{
    <CLASS> ID() "{"
        <PUBLIC> <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" ID() ")" "{"
            Statement()
        "}"
    "}"
}

void ClassDeclaration() : {}
{
    <CLASS> ID() (<EXTENDS> ID())? "{"
        (VarDeclaration())* (MethodDeclaration())*
    "}"
}

void VarDeclaration() : {}
{
    Type() ID() <SEMI>
}

void MethodDeclaration() : {}
{
    <PUBLIC> Type() ID() "("
        (Type() ID() ( "," Type() ID())* )?
    ")" "{"
        (LOOKAHEAD(2) VarDeclaration())*
        (Statement())*
        "return" Expression() <SEMI>
    "}"
}

void Type() : {}
{
    LOOKAHEAD(2)
      <INT>
    | <INT> "/[" "]"
    | <BOOLEAN>
    | ID()
}

void Statement() : {}
{
    "{" (Statement())* "}"
    | <IF> "(" Expression() ")" <ELSE> Statement()
    | <WHILE> "(" Expression() ")" Statement()
    | <PRINT> "(" Expression() ")"
    | LOOKAHEAD(6)
      ID() "=" Expression() ";"
    | ID() "[" Expression() "]" "=" Expression() <SEMI>
}

/*
void Expression() : {}
{
    <THIS>
    | <TRUE>
    | <FALSE>
    | <INTEGER_LITERAL>
    | ID()
    | LOOKAHEAD(2)
      <NEW> <INT> "[" Expression() "]"
    | <NEW> ID() "(" ")"
    | "!" Expression()
    | "(" Expression() ")"
    | LOOKAHEAD(3)
      Expression() "." <LENGTH>
    | Expression() "[" Expression() "]"
    | Expression() BinaryOperator() Expression()
    | Expression() "." ID() "(" ( Expression() ( "," Expression() )* )? ")"
}
*/

void Expression() : {}
{
    LOOKAHEAD(1)
      Expr1()
    | Expr1() Expr2()
}

void Expr1() : {}
{
    <THIS>
    | <TRUE>
    | <FALSE>
    | <INTEGER_LITERAL>
    | ID()
    | "!" Expression()
    | "(" Expression() ")"
    | LOOKAHEAD(1)
      <NEW> <INT> "[" Expression() "]"
    | <NEW> ID() "(" ")"
}

void Expr2() : {}
{
    BinaryOperator() Expression()
    | LOOKAHEAD(1)
      "." <LENGTH>
    | "." ID() "(" ( Expression() ( "," Expression() )* )? ")"
}

void BinaryOperator() : {}
{
    <OP_AND> | <OP_LESS> | <OP_ADD> | <OP_SUB> | <OP_MULT>
}

void ID() : {} { <ID> }